<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Picasa</title>
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap">
  <style>
    body {
      background: #0c0c0d;
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Quicksand', 'SF Pro Display', 'SF Pro', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif;
    }
    .picasa-bg-blur {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      background-image: url('./assets/image2.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(24px) brightness(0.7);
      opacity: 0.7;
      pointer-events: none;
    }
    .picasa-content-wrapper {
      position: relative;
      z-index: 1;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: inherit;
      overflow: hidden;
    }

    /* Vertical Scrolling Masonry Container */
    .masonry-container {
      padding-top: 60px;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      gap: 16px;
      justify-content: center;
      align-items: flex-start;
    }

    .masonry-column {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 280px;
      flex-shrink: 0;
      will-change: transform;
    }

    .masonry-item {
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      flex-shrink: 0;
      width: 100%;
    }

    .masonry-item:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      z-index: 10;
    }

    .masonry-item img {
      width: 100%;
      height: auto;
      max-height: 400px;
      object-fit: cover;
      display: block;
      border-radius: 8px;
      transition: transform 0.3s ease;
    }

    /* Lightbox styles */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .lightbox.active {
      display: flex;
      opacity: 1;
    }

    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: zoomIn 0.3s ease;
      z-index: 1000;
    }

    @keyframes zoomIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .lightbox-image-container {
      position: relative;
      max-width: 90vw;
      max-height: 75vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content img {
      max-width: 100%;
      max-height: 75vh;
      border-radius: 8px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.8);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .lightbox-content img.zoomed {
      max-width: 98vw;
      max-height: 98vh;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 0;
      cursor: zoom-out;
    }

    .lightbox-close {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: none;
      border-radius: 50%;
      color: #fff;
      font-size: 36px;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      line-height: 1;
      z-index: 1002;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-close:hover {
      transform: scale(1.1);
      background: rgba(0, 0, 0, 0.9);
    }

    /* Carousel navigation arrows - cinema style */
    .lightbox-arrow {
      position: fixed;
      top: calc(50% + 50px);
      transform: translateY(-50%);
      width: 150px;
      height: 300px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1001;
    }

    .lightbox:hover .lightbox-arrow {
      opacity: 0.7;
    }

    .lightbox-arrow:hover {
      opacity: 1 !important;
      transform: translateY(-50%) scale(1.05);
    }

    .lightbox-arrow svg {
      width: 70px;
      height: 70px;
      fill: none;
      stroke: #fff;
      stroke-width: 5;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.9));
      pointer-events: none;
    }

    .lightbox-arrow:hover svg {
      stroke-width: 6;
      filter: drop-shadow(0 0 16px rgba(255, 255, 255, 1));
    }

    .lightbox-arrow-left {
      left: 0;
      justify-content: flex-start;
      padding-left: 20px;
    }

    .lightbox-arrow-right {
      right: 0;
      justify-content: flex-end;
      padding-right: 20px;
    }

    /* Image metadata display */
    .image-metadata {
      margin-top: 20px;
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      max-width: 600px;
      color: #ededed;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .metadata-row {
      margin: 5px 0;
    }

    .metadata-label {
      color: #aaa;
      display: inline-block;
      width: 120px;
    }

    .metadata-value {
      color: #fff;
      font-weight: 600;
    }

    /* Responsive sizing */
    @media (max-width: 1200px) {
      .masonry-column {
        width: 240px;
      }
    }

    @media (max-width: 900px) {
      .masonry-column {
        width: 200px;
      }
      .masonry-container {
        gap: 12px;
      }
    }

    @media (max-width: 768px) {
      .masonry-column {
        width: 180px;
      }
      .masonry-container {
        padding-top: 60px;
        gap: 10px;
      }
      .masonry-item {
        border-radius: 6px;
      }
      .masonry-item img {
        border-radius: 6px;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
      .lightbox-arrow {
        width: 100px;
        height: 250px;
      }
      .lightbox-arrow svg {
        width: 50px;
        height: 50px;
      }
      .lightbox-arrow-left {
        left: 0;
        padding-left: 10px;
      }
      .lightbox-arrow-right {
        right: 0;
        padding-right: 10px;
      }
      .lightbox-close {
        top: 10px;
        right: 10px;
        width: 45px;
        height: 45px;
        font-size: 32px;
      }
    }

    @media (max-width: 480px) {
      .masonry-column {
        width: 140px;
      }
      .masonry-container {
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <script src="./url-handler.js"></script>
  <div class="picasa-bg-blur"></div>
  <div class="picasa-content-wrapper">
    <nav>
      <div class="nav-links">
        <a href="./">Home</a>
        <a href="./arcade">Arcade</a>
        <a href="./picasa" class="active">Picasa</a>
        <a href="./cinema">Cinema</a>
        <a href="./melody">Melody</a>
      </div>
    </nav>
    
    <div class="masonry-container" id="masonryContainer">
      <!-- Columns will be dynamically loaded here -->
    </div>
  </div>

  <!-- Lightbox for image popup with carousel -->
  <div class="lightbox" id="lightbox">
    <button class="lightbox-close" id="lightboxClose">&times;</button>
    
    <!-- Previous arrow -->
    <button class="lightbox-arrow lightbox-arrow-left" id="lightboxPrev">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="40,15 20,35 40,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    
    <div class="lightbox-content">
      <div class="lightbox-image-container">
        <img src="" alt="Enlarged view" id="lightboxImg">
      </div>
      
      <!-- Image metadata -->
      <div class="image-metadata" id="imageMetadata" style="display: none;">
        <!-- Metadata will be populated here -->
      </div>
    </div>
    
    <!-- Next arrow -->
    <button class="lightbox-arrow lightbox-arrow-right" id="lightboxNext">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="30,15 50,35 30,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <script>
    // Images from assets folder (excluding those used in cinema.html or arcade.html)
    const imagePaths = [
      './assets/IMG_20240708_081641.jpg',
      './assets/Test-4.jpg',
      './assets/IMG_20240314_122106-ps.jpg',
      './assets/IMG_20240709_122550.jpg',
      './assets/Sunset.jpg',
      './assets/post4-1.jpg',
      './assets/IMG_20240707_191957-ps.jpg',
      './assets/IMG_20240709_122741.jpg',
      './assets/IMG_20240708_094943.jpg',
      './assets/IMG_20240709_121543.jpg',
      './assets/Parrot-3.jpg',
      './assets/post-2.jpg',
      './assets/IMG_20240709_120009.jpg',
      './assets/post3-2.jpg',
      './assets/Parrot-2.jpg',
      './assets/Test-1.jpg',
      './assets/Insta-2.jpg',
      './assets/shiv.jpg',
      './assets/post.jpg',
      './assets/IMG_20240708_091039-ps.jpg',
      './assets/IMG_20250411_184811.jpg',
      './assets/IMG_20240709_121028.jpg',
      './assets/image2.png',
      './assets/IMG_20240709_121046.jpg',
      './assets/done1.jpg',
      './assets/post-3.jpg',
      './assets/IMG_20240709_120404.jpg',
      './assets/done1-1.jpg',
      './assets/IMG_20240709_122256.jpg',
      './assets/post-4.jpg',
      './assets/post3.jpg',
      './assets/IMG_20250607_081810.jpg',
      './assets/post-1.jpg',
      './assets/IMG_20240314_125103.jpg',
      './assets/image3.png',
      './assets/IMG_20240708_132053.jpg'
    ];

    let shuffledImages = [];
    let currentLightboxIndex = 0;
    const numColumns = 5; // Number of columns

    // Fisher-Yates shuffle algorithm to randomize array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Populate the masonry grid with vertical scrolling columns
    function populateMasonryGrid() {
      const container = document.getElementById('masonryContainer');
      container.innerHTML = ''; // Clear existing content
      
      shuffledImages = shuffleArray(imagePaths);
      
      // Create columns
      const columns = [];
      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'masonry-column';
        column.dataset.columnIndex = i;
        columns.push(column);
        container.appendChild(column);
      }
      
      // Distribute images to columns and duplicate for seamless looping
      const imagesPerColumn = Math.ceil(shuffledImages.length / numColumns);
      
      columns.forEach((column, colIndex) => {
        const startIdx = colIndex * imagesPerColumn;
        const endIdx = Math.min(startIdx + imagesPerColumn, shuffledImages.length);
        const columnImages = shuffledImages.slice(startIdx, endIdx);
        
        // Duplicate images for seamless looping (3 copies for smooth infinite scroll)
        const imagesToRender = [...columnImages, ...columnImages, ...columnImages];
        
        imagesToRender.forEach((imagePath, localIndex) => {
          const originalIndex = startIdx + (localIndex % columnImages.length);
          const item = document.createElement('div');
          item.className = 'masonry-item';
          
          const img = document.createElement('img');
          img.src = imagePath;
          img.alt = `Gallery image ${originalIndex + 1}`;
          img.loading = 'lazy';
          img.dataset.index = originalIndex;
          
          // Add click event for lightbox
          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openLightbox(originalIndex);
          });
          
          item.appendChild(img);
          column.appendChild(item);
        });
        
        // Start vertical scrolling animation for this column
        startColumnAnimation(column, colIndex);
      });
    }

    // Track hover state and pause info for each column
    const columnStates = {};
    
    // Vertical infinite scroll animation with dynamic image recycling
    function startColumnAnimation(column, colIndex) {
      // Get all images in column (already tripled)
      const items = Array.from(column.children);
      const baseImageCount = items.length / 3; // Original count before tripling
      
      // Different speeds for each column (5 seconds for testing)
      const baseSpeed = 5;
      const speedVariation = (colIndex * 0.2) - 0.4; // Slight variation per column
      const duration = baseSpeed + speedVariation;
      const pixelsPerSecond = 50; // Constant scroll speed in pixels/sec
      
      // Alternate directions for variety
      const direction = colIndex % 2 === 0 ? 1 : -1;
      
      // Start position
      let currentPosition = 0;
      
      let animationId = null;
      let lastFrameTime = performance.now();
      
      // Initialize column state
      columnStates[colIndex] = {
        isPaused: false,
        hoverStartTime: null,
        userScrollVelocity: 0,
        isUserScrolling: false
      };
      
      const state = columnStates[colIndex];
      
      // Add hover listeners to each image in column for pause on hover
      items.forEach(item => {
        item.addEventListener('mouseenter', () => {
          state.hoverStartTime = performance.now();
        });
        
        item.addEventListener('mouseleave', () => {
          state.hoverStartTime = null;
          state.isPaused = false;
        });
      });
      
      // Add scroll wheel control for any column
      column.addEventListener('wheel', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Only allow scrolling opposite to the column's natural direction
        const scrollDirection = e.deltaY > 0 ? -1 : 1; // deltaY > 0 = scroll down
        
        // Check if user is trying to scroll opposite to the column's auto-scroll direction
        if (scrollDirection !== direction) {
          // User control overrides auto-scroll temporarily
          state.isUserScrolling = true;
          
          // Add to user scroll velocity with reduced speed (0.15 instead of 0.5)
          state.userScrollVelocity += e.deltaY * 0.15;
          
          // Reset user scrolling flag after a delay
          clearTimeout(state.scrollTimeout);
          state.scrollTimeout = setTimeout(() => {
            state.isUserScrolling = false;
            // Gradually decay user velocity back to auto-scroll
            const decayInterval = setInterval(() => {
              if (Math.abs(state.userScrollVelocity) < 1) {
                state.userScrollVelocity = 0;
                clearInterval(decayInterval);
              } else {
                state.userScrollVelocity *= 0.95;
              }
            }, 16);
          }, 150);
        }
      }, { passive: false });
      
      function animate(currentTime) {
        const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
        lastFrameTime = currentTime;
        
        // Check if should pause due to hover (0.5 second delay)
        if (state.hoverStartTime && !state.isPaused) {
          const hoverDuration = currentTime - state.hoverStartTime;
          if (hoverDuration >= 500) { // 0.5 second = 500ms
            state.isPaused = true;
          }
        }
        
        // Calculate movement
        let movement = 0;
        
        if (state.isPaused && !state.isUserScrolling) {
          // Paused - no movement
          movement = 0;
        } else if (state.isUserScrolling) {
          // User is scrolling - use user velocity
          movement = state.userScrollVelocity * deltaTime * 60; // Scale for frame rate
        } else {
          // Auto-scroll mode
          movement = (pixelsPerSecond * deltaTime) * direction;
          
          // Blend in any remaining user velocity
          if (Math.abs(state.userScrollVelocity) > 0.1) {
            movement += state.userScrollVelocity * deltaTime * 30;
          }
        }
        
        currentPosition += movement;
        
        // Dynamic image recycling based on direction
        // Only recycle when images are completely off-screen
        const viewportHeight = window.innerHeight;
        
        if (direction === 1) {
          // Scrolling upward - remove from bottom when completely off-screen below
          const lastItem = column.lastElementChild;
          if (lastItem) {
            const itemRect = lastItem.getBoundingClientRect();
            // Only recycle when image is completely below viewport
            if (itemRect.top > viewportHeight + 100) {
              column.removeChild(lastItem);
              column.insertBefore(lastItem, column.firstElementChild);
              currentPosition -= lastItem.offsetHeight + 16; // Adjust for gap
            }
          }
        } else {
          // Scrolling downward - remove from top when completely off-screen above
          const firstItem = column.firstElementChild;
          if (firstItem) {
            const itemRect = firstItem.getBoundingClientRect();
            // Only recycle when image is completely above viewport
            if (itemRect.bottom < -100) {
              column.removeChild(firstItem);
              column.appendChild(firstItem);
              currentPosition += firstItem.offsetHeight + 16; // Adjust for gap
            }
          }
        }
        
        // Use transform for smooth GPU-accelerated animation
        column.style.transform = `translateY(${currentPosition}px)`;
        animationId = requestAnimationFrame(animate);
      }
      
      // Start animation
      animationId = requestAnimationFrame(animate);
    }

    // Read EXIF metadata from image
    function readImageMetadata(imgElement, callback) {
      // Check if EXIF library is available
      if (typeof EXIF === 'undefined') {
        callback({}); // Return empty metadata if library not available
        return;
      }
      
      EXIF.getData(imgElement, function() {
        const metadata = {
          make: EXIF.getTag(this, "Make"),
          model: EXIF.getTag(this, "Model"),
          dateTime: EXIF.getTag(this, "DateTime"),
          focalLength: EXIF.getTag(this, "FocalLength"),
          aperture: EXIF.getTag(this, "FNumber"),
          iso: EXIF.getTag(this, "ISOSpeedRatings"),
          exposureTime: EXIF.getTag(this, "ExposureTime"),
          lens: EXIF.getTag(this, "LensModel")
        };
        callback(metadata);
      });
    }

    // Display image metadata
    function displayMetadata(metadata) {
      const metadataDiv = document.getElementById('imageMetadata');
      let html = '';

      // Always show fields, use N/A if not available
      const dateTime = metadata.dateTime || 'N/A';
      html += `<div class="metadata-row"><span class="metadata-label">Date & Time:</span> <span class="metadata-value">${dateTime}</span></div>`;

      const camera = (metadata.make || metadata.model) ? 
        [metadata.make, metadata.model].filter(Boolean).join(' ') : 'N/A';
      html += `<div class="metadata-row"><span class="metadata-label">Camera:</span> <span class="metadata-value">${camera}</span></div>`;

      const lens = metadata.lens || 'N/A';
      html += `<div class="metadata-row"><span class="metadata-label">Lens:</span> <span class="metadata-value">${lens}</span></div>`;

      let focal = 'N/A';
      if (metadata.focalLength) {
        focal = metadata.focalLength.numerator ? 
          `${metadata.focalLength.numerator / metadata.focalLength.denominator}mm` : 
          `${metadata.focalLength}mm`;
      }
      html += `<div class="metadata-row"><span class="metadata-label">Focal Length:</span> <span class="metadata-value">${focal}</span></div>`;

      let aperture = 'N/A';
      if (metadata.aperture) {
        aperture = metadata.aperture.numerator ? 
          `f/${(metadata.aperture.numerator / metadata.aperture.denominator).toFixed(1)}` : 
          `f/${metadata.aperture}`;
      }
      html += `<div class="metadata-row"><span class="metadata-label">Aperture:</span> <span class="metadata-value">${aperture}</span></div>`;

      let exposure = 'N/A';
      if (metadata.exposureTime) {
        exposure = metadata.exposureTime.numerator ? 
          `${metadata.exposureTime.numerator}/${metadata.exposureTime.denominator}s` : 
          `${metadata.exposureTime}s`;
      }
      html += `<div class="metadata-row"><span class="metadata-label">Shutter Speed:</span> <span class="metadata-value">${exposure}</span></div>`;

      const iso = metadata.iso || 'N/A';
      html += `<div class="metadata-row"><span class="metadata-label">ISO:</span> <span class="metadata-value">${iso}</span></div>`;

      metadataDiv.innerHTML = html;
      metadataDiv.style.display = 'block';
    }

    // Lightbox functionality
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');

    function openLightbox(index) {
      currentLightboxIndex = index;
      showLightboxImage();
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function showLightboxImage() {
      const imageSrc = shuffledImages[currentLightboxIndex];
      lightboxImg.src = imageSrc;
      
      // Remove zoomed class when changing images
      lightboxImg.classList.remove('zoomed');
      
      // Show metadata
      document.getElementById('imageMetadata').style.display = 'block';
      
      // Read and display metadata
      lightboxImg.onload = function() {
        readImageMetadata(lightboxImg, displayMetadata);
      };
    }

    // Toggle zoom on image click/tap
    lightboxImg.addEventListener('click', function(e) {
      e.stopPropagation();
      const isZoomed = this.classList.toggle('zoomed');
      
      // Hide/show metadata based on zoom state
      const metadataDiv = document.getElementById('imageMetadata');
      if (isZoomed) {
        metadataDiv.style.display = 'none';
      } else {
        metadataDiv.style.display = 'block';
      }
    });

    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
      document.getElementById('imageMetadata').style.display = 'none';
    }

    function showPrevImage() {
      currentLightboxIndex = (currentLightboxIndex - 1 + shuffledImages.length) % shuffledImages.length;
      showLightboxImage();
    }

    function showNextImage() {
      currentLightboxIndex = (currentLightboxIndex + 1) % shuffledImages.length;
      showLightboxImage();
    }

    // Event listeners
    lightboxClose.addEventListener('click', (e) => {
      e.stopPropagation();
      closeLightbox();
    });
    
    lightboxPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      showPrevImage();
    });
    
    lightboxNext.addEventListener('click', (e) => {
      e.stopPropagation();
      showNextImage();
    });
    
    // Close lightbox when clicking outside the image
    lightbox.addEventListener('click', function(e) {
      if (e.target === lightbox) {
        closeLightbox();
      }
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      if (e.key === 'Escape') {
        closeLightbox();
      } else if (e.key === 'ArrowLeft') {
        showPrevImage();
      } else if (e.key === 'ArrowRight') {
        showNextImage();
      }
    });

    // Touch swipe support for mobile
    let touchStartX = 0;
    let touchEndX = 0;
    
    lightbox.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });
    
    lightbox.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    }, { passive: true });
    
    function handleSwipe() {
      const swipeThreshold = 50;
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Swipe left - next image
          showNextImage();
        } else {
          // Swipe right - previous image
          showPrevImage();
        }
      }
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
      populateMasonryGrid();
    });
  </script>
</body>
</html>
