<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Picasa</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap">
  <style>
    body {
      background: #0c0c0d;
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Quicksand', 'SF Pro Display', 'SF Pro', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif;
    }
    .picasa-bg-blur {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      background-image: url('../assets/image2.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(24px) brightness(0.7);
      opacity: 0.7;
      pointer-events: none;
    }
    .picasa-content-wrapper {
      position: relative;
      z-index: 1;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: inherit;
      overflow: hidden;
    }

    /* Vertical Scrolling Masonry Container */
    .masonry-container {
      padding-top: 60px;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      gap: 16px;
      justify-content: center;
      align-items: flex-start;
    }

    .masonry-column {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 280px;
      flex-shrink: 0;
      will-change: transform;
    }

    .masonry-item {
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      flex-shrink: 0;
      width: 100%;
    }

    .masonry-item:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      z-index: 10;
    }

    .masonry-item img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 8px;
      transition: transform 0.3s ease;
    }

    /* Lightbox styles */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .lightbox.active {
      display: flex;
      opacity: 1;
    }

    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: zoomIn 0.3s ease;
      z-index: 1000;
    }

    @keyframes zoomIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .lightbox-image-container {
      position: relative;
      max-width: 90vw;
      max-height: 75vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content img {
      max-width: 100%;
      max-height: 75vh;
      border-radius: 8px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.8);
    }

    .lightbox-close {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: none;
      border-radius: 50%;
      color: #fff;
      font-size: 36px;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      line-height: 1;
      z-index: 1002;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-close:hover {
      transform: scale(1.1);
      background: rgba(0, 0, 0, 0.9);
    }

    /* Carousel navigation arrows - cinema style */
    .lightbox-arrow {
      position: fixed;
      top: calc(50% + 50px);
      transform: translateY(-50%);
      width: 150px;
      height: 300px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1001;
    }

    .lightbox:hover .lightbox-arrow {
      opacity: 0.7;
    }

    .lightbox-arrow:hover {
      opacity: 1 !important;
      transform: translateY(-50%) scale(1.05);
    }

    .lightbox-arrow svg {
      width: 70px;
      height: 70px;
      fill: none;
      stroke: #fff;
      stroke-width: 5;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.9));
      pointer-events: none;
    }

    .lightbox-arrow:hover svg {
      stroke-width: 6;
      filter: drop-shadow(0 0 16px rgba(255, 255, 255, 1));
    }

    .lightbox-arrow-left {
      left: 0;
      justify-content: flex-start;
      padding-left: 20px;
    }

    .lightbox-arrow-right {
      right: 0;
      justify-content: flex-end;
      padding-right: 20px;
    }

    /* Image metadata display */
    .image-metadata {
      margin-top: 20px;
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      max-width: 600px;
      color: #ededed;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .metadata-row {
      margin: 5px 0;
    }

    .metadata-label {
      color: #aaa;
      display: inline-block;
      width: 120px;
    }

    .metadata-value {
      color: #fff;
      font-weight: 600;
    }

    /* Responsive sizing */
    @media (max-width: 1200px) {
      .masonry-column {
        width: 240px;
      }
    }

    @media (max-width: 900px) {
      .masonry-column {
        width: 200px;
      }
      .masonry-container {
        gap: 12px;
      }
    }

    @media (max-width: 768px) {
      .masonry-column {
        width: 180px;
      }
      .masonry-container {
        padding-top: 60px;
        gap: 10px;
      }
      .masonry-item {
        border-radius: 6px;
      }
      .masonry-item img {
        border-radius: 6px;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
      .lightbox-arrow {
        width: 100px;
        height: 250px;
      }
      .lightbox-arrow svg {
        width: 50px;
        height: 50px;
      }
      .lightbox-arrow-left {
        left: 0;
        padding-left: 10px;
      }
      .lightbox-arrow-right {
        right: 0;
        padding-right: 10px;
      }
      .lightbox-close {
        top: 10px;
        right: 10px;
        width: 45px;
        height: 45px;
        font-size: 32px;
      }
    }

    @media (max-width: 480px) {
      .masonry-column {
        width: 140px;
      }
      .masonry-container {
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <script src="../url-handler.js"></script>
  <div class="picasa-bg-blur"></div>
  <div class="picasa-content-wrapper">
    <nav>
      <div class="nav-links">
        <a href="../">Home</a>
        <a href="../arcade">Arcade</a>
        <a href="../picasa" class="active">Picasa</a>
        <a href="../cinema">Cinema</a>
        <a href="../melody">Melody</a>
      </div>
    </nav>
    
    <div class="masonry-container" id="masonryContainer">
      <!-- Columns will be dynamically loaded here -->
    </div>
  </div>

  <!-- Lightbox for image popup with carousel -->
  <div class="lightbox" id="lightbox">
    <button class="lightbox-close" id="lightboxClose">&times;</button>
    
    <!-- Previous arrow -->
    <button class="lightbox-arrow lightbox-arrow-left" id="lightboxPrev">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="40,15 20,35 40,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    
    <div class="lightbox-content">
      <div class="lightbox-image-container">
        <img src="" alt="Enlarged view" id="lightboxImg">
      </div>
      
      <!-- Image metadata -->
      <div class="image-metadata" id="imageMetadata" style="display: none;">
        <!-- Metadata will be populated here -->
      </div>
    </div>
    
    <!-- Next arrow -->
    <button class="lightbox-arrow lightbox-arrow-right" id="lightboxNext">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="30,15 50,35 30,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <script>
    // Collect all image paths from assets and posters folders
    const imagePaths = [
      // Assets folder
      '../assets/battlefield4.png',
      '../assets/blasphemous.png',
      '../assets/ghostoftsushima.png',
      '../assets/igi2.png',
      '../assets/image1.png',
      '../assets/image2.png',
      '../assets/image3.png',
      '../assets/image4.png',
      '../assets/justcause2.png',
      '../assets/needforspeedmostwanted.png',
      '../assets/onimusha3.png',
      '../assets/reddeadredemption2.png',
      '../assets/residentevilvillage.png',
      '../assets/trackmania.png',
      '../assets/trailmakers.png',
      // Posters folder
      '../posters/From.png',
      '../posters/IT.png',
      '../posters/Incantation.png',
      '../posters/Iron Man.png',
      '../posters/Taare Zameen Par.png',
      '../posters/The Others.png',
      '../posters/The Wailing.png',
      '../posters/Tokyo Drift.png',
      '../posters/You.png',
      '../posters/cars 3.jpg',
      '../posters/chernobyl.png',
      '../posters/dark.png',
      '../posters/dexter.png',
      '../posters/monster.png',
      '../posters/tokyo ghoul.png',
      '../posters/tumbbad.png'
    ];

    let shuffledImages = [];
    let currentLightboxIndex = 0;
    const numColumns = 5; // Number of columns

    // Fisher-Yates shuffle algorithm to randomize array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Populate the masonry grid with vertical scrolling columns
    function populateMasonryGrid() {
      const container = document.getElementById('masonryContainer');
      container.innerHTML = ''; // Clear existing content
      
      shuffledImages = shuffleArray(imagePaths);
      
      // Create columns
      const columns = [];
      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'masonry-column';
        column.dataset.columnIndex = i;
        columns.push(column);
        container.appendChild(column);
      }
      
      // Distribute images to columns and duplicate for seamless looping
      const imagesPerColumn = Math.ceil(shuffledImages.length / numColumns);
      
      columns.forEach((column, colIndex) => {
        const startIdx = colIndex * imagesPerColumn;
        const endIdx = Math.min(startIdx + imagesPerColumn, shuffledImages.length);
        const columnImages = shuffledImages.slice(startIdx, endIdx);
        
        // Duplicate images for seamless looping (3 copies for smooth infinite scroll)
        const imagesToRender = [...columnImages, ...columnImages, ...columnImages];
        
        imagesToRender.forEach((imagePath, localIndex) => {
          const originalIndex = startIdx + (localIndex % columnImages.length);
          const item = document.createElement('div');
          item.className = 'masonry-item';
          
          const img = document.createElement('img');
          img.src = imagePath;
          img.alt = `Gallery image ${originalIndex + 1}`;
          img.loading = 'lazy';
          img.dataset.index = originalIndex;
          
          // Add click event for lightbox
          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openLightbox(originalIndex);
          });
          
          item.appendChild(img);
          column.appendChild(item);
        });
        
        // Start vertical scrolling animation for this column
        startColumnAnimation(column, colIndex);
      });
    }

    // Vertical infinite scroll animation for each column
    function startColumnAnimation(column, colIndex) {
      const columnHeight = column.scrollHeight / 3; // 1/3 height since we tripled
      let currentPosition = 0;
      
      // Different speeds for each column (15-20 seconds per full loop)
      const baseSpeed = 15 + (colIndex * 1);
      const speedVariation = Math.random() * 2 - 1;
      const duration = baseSpeed + speedVariation;
      const speed = columnHeight / duration; // pixels per second
      
      // Alternate directions for variety
      const direction = colIndex % 2 === 0 ? 1 : -1;
      
      // Initialize position for downward scrolling columns
      if (direction === -1) {
        currentPosition = -columnHeight; // Start at -columnHeight for downward
      }
      
      function animate() {
        currentPosition += (speed / 60) * direction; // 60fps
        
        // Loop seamlessly
        if (direction === 1) {
          // Scrolling upward (positive direction)
          if (currentPosition >= columnHeight) {
            currentPosition -= columnHeight;
          }
        } else {
          // Scrolling downward (negative direction)
          if (currentPosition >= 0) {
            currentPosition = -columnHeight; // Reset to start position
          }
        }
        
        column.style.transform = `translateY(${currentPosition}px)`;
        requestAnimationFrame(animate);
      }
      
      // Start animation
      requestAnimationFrame(animate);
    }

    // Read EXIF metadata from image
    function readImageMetadata(imgElement, callback) {
      // Check if EXIF library is available
      if (typeof EXIF === 'undefined') {
        callback({}); // Return empty metadata if library not available
        return;
      }
      
      EXIF.getData(imgElement, function() {
        const metadata = {
          make: EXIF.getTag(this, "Make"),
          model: EXIF.getTag(this, "Model"),
          dateTime: EXIF.getTag(this, "DateTime"),
          focalLength: EXIF.getTag(this, "FocalLength"),
          aperture: EXIF.getTag(this, "FNumber"),
          iso: EXIF.getTag(this, "ISOSpeedRatings"),
          exposureTime: EXIF.getTag(this, "ExposureTime"),
          lens: EXIF.getTag(this, "LensModel")
        };
        callback(metadata);
      });
    }

    // Display image metadata
    function displayMetadata(metadata) {
      const metadataDiv = document.getElementById('imageMetadata');
      let hasMetadata = false;
      let html = '';

      if (metadata.dateTime) {
        html += `<div class="metadata-row"><span class="metadata-label">Date & Time:</span> <span class="metadata-value">${metadata.dateTime}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.make || metadata.model) {
        const camera = [metadata.make, metadata.model].filter(Boolean).join(' ');
        html += `<div class="metadata-row"><span class="metadata-label">Camera:</span> <span class="metadata-value">${camera}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.lens) {
        html += `<div class="metadata-row"><span class="metadata-label">Lens:</span> <span class="metadata-value">${metadata.lens}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.focalLength) {
        const focal = metadata.focalLength.numerator ? 
          `${metadata.focalLength.numerator / metadata.focalLength.denominator}mm` : 
          `${metadata.focalLength}mm`;
        html += `<div class="metadata-row"><span class="metadata-label">Focal Length:</span> <span class="metadata-value">${focal}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.aperture) {
        const aperture = metadata.aperture.numerator ? 
          `f/${(metadata.aperture.numerator / metadata.aperture.denominator).toFixed(1)}` : 
          `f/${metadata.aperture}`;
        html += `<div class="metadata-row"><span class="metadata-label">Aperture:</span> <span class="metadata-value">${aperture}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.exposureTime) {
        const exposure = metadata.exposureTime.numerator ? 
          `${metadata.exposureTime.numerator}/${metadata.exposureTime.denominator}s` : 
          `${metadata.exposureTime}s`;
        html += `<div class="metadata-row"><span class="metadata-label">Shutter Speed:</span> <span class="metadata-value">${exposure}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.iso) {
        html += `<div class="metadata-row"><span class="metadata-label">ISO:</span> <span class="metadata-value">${metadata.iso}</span></div>`;
        hasMetadata = true;
      }

      if (hasMetadata) {
        metadataDiv.innerHTML = html;
        metadataDiv.style.display = 'block';
      } else {
        metadataDiv.style.display = 'none';
      }
    }

    // Lightbox functionality
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');

    function openLightbox(index) {
      currentLightboxIndex = index;
      showLightboxImage();
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function showLightboxImage() {
      const imageSrc = shuffledImages[currentLightboxIndex];
      lightboxImg.src = imageSrc;
      
      // Read and display metadata
      lightboxImg.onload = function() {
        readImageMetadata(lightboxImg, displayMetadata);
      };
    }

    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
      document.getElementById('imageMetadata').style.display = 'none';
    }

    function showPrevImage() {
      currentLightboxIndex = (currentLightboxIndex - 1 + shuffledImages.length) % shuffledImages.length;
      showLightboxImage();
    }

    function showNextImage() {
      currentLightboxIndex = (currentLightboxIndex + 1) % shuffledImages.length;
      showLightboxImage();
    }

    // Event listeners
    lightboxClose.addEventListener('click', (e) => {
      e.stopPropagation();
      closeLightbox();
    });
    
    lightboxPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      showPrevImage();
    });
    
    lightboxNext.addEventListener('click', (e) => {
      e.stopPropagation();
      showNextImage();
    });
    
    // Close lightbox when clicking outside the image
    lightbox.addEventListener('click', function(e) {
      if (e.target === lightbox) {
        closeLightbox();
      }
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      if (e.key === 'Escape') {
        closeLightbox();
      } else if (e.key === 'ArrowLeft') {
        showPrevImage();
      } else if (e.key === 'ArrowRight') {
        showNextImage();
      }
    });

    // Touch swipe support for mobile
    let touchStartX = 0;
    let touchEndX = 0;
    
    lightbox.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });
    
    lightbox.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    }, { passive: true });
    
    function handleSwipe() {
      const swipeThreshold = 50;
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Swipe left - next image
          showNextImage();
        } else {
          // Swipe right - previous image
          showPrevImage();
        }
      }
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
      populateMasonryGrid();
    });
  </script>
</body>
</html>
