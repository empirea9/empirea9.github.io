<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Picasa</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap">
  <style>
    body {
      background: #0c0c0d;
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Quicksand', 'SF Pro Display', 'SF Pro', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif;
    }
    .picasa-bg-blur {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      background-image: url('../assets/image2.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(24px) brightness(0.7);
      opacity: 0.7;
      pointer-events: none;
    }
    .picasa-content-wrapper {
      position: relative;
      z-index: 1;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: inherit;
      overflow: hidden;
    }

    /* Vertical Scrolling Masonry Container */
    .masonry-container {
      padding-top: 60px;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      gap: 16px;
      justify-content: center;
      align-items: flex-start;
    }

    .masonry-column {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 280px;
      flex-shrink: 0;
      backface-visibility: hidden;
      transform: translate3d(0, 0, 0);
      will-change: transform;
      -webkit-transform: translate3d(0, 0, 0);
      -webkit-backface-visibility: hidden;
      perspective: 1000px;
    }

    .masonry-item {
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      flex-shrink: 0;
      width: 100%;
      background: #1a1a1a;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }

    .masonry-item:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      z-index: 10;
    }

    /* Loading state with blur effect */
    .masonry-item.loading::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 26, 26, 0.8);
      backdrop-filter: blur(10px);
      z-index: 10;
      pointer-events: none;
    }

    .masonry-item img {
      width: 100%;
      height: auto;
      max-height: 380px;
      object-fit: cover;
      display: block;
      border-radius: 8px;
      transition: opacity 0.3s ease;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      opacity: 0;
    }

    .masonry-item img.loaded {
      opacity: 1;
    }

    /* Lightbox styles */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .lightbox.active {
      display: flex;
      opacity: 1;
    }

    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: zoomIn 0.3s ease;
      z-index: 1000;
    }

    @keyframes zoomIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .lightbox-image-container {
      position: relative;
      max-width: 90vw;
      max-height: 75vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content img {
      max-width: 100%;
      max-height: 75vh;
      border-radius: 8px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.8);
      cursor: pointer;
      transition: all 0.3s ease;
      will-change: transform;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .lightbox-content img.zoomed {
      max-width: 98vw;
      max-height: 98vh;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 0;
      cursor: zoom-out;
    }

    .lightbox-close {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: none;
      border-radius: 50%;
      color: #fff;
      font-size: 36px;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      line-height: 1;
      z-index: 1002;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-close:hover {
      transform: scale(1.1);
      background: rgba(0, 0, 0, 0.9);
    }

    /* Carousel navigation arrows - cinema style */
    .lightbox-arrow {
      position: fixed;
      top: calc(50% + 50px);
      transform: translateY(-50%);
      width: 150px;
      height: 300px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1001;
    }

    .lightbox:hover .lightbox-arrow {
      opacity: 0.7;
    }

    .lightbox-arrow:hover {
      opacity: 1 !important;
      transform: translateY(-50%) scale(1.05);
    }

    .lightbox-arrow svg {
      width: 70px;
      height: 70px;
      fill: none;
      stroke: #fff;
      stroke-width: 5;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.9));
      pointer-events: none;
    }

    .lightbox-arrow:hover svg {
      stroke-width: 6;
      filter: drop-shadow(0 0 16px rgba(255, 255, 255, 1));
    }

    .lightbox-arrow-left {
      left: 0;
      justify-content: flex-start;
      padding-left: 20px;
    }

    .lightbox-arrow-right {
      right: 0;
      justify-content: flex-end;
      padding-right: 20px;
    }

    /* Image metadata display */
    .image-metadata {
      margin-top: 20px;
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      max-width: 600px;
      color: #ededed;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .metadata-row {
      margin: 5px 0;
    }

    .metadata-label {
      color: #aaa;
      display: inline-block;
      width: 120px;
    }

    .metadata-value {
      color: #fff;
      font-weight: 600;
    }

    /* Responsive sizing */
    @media (max-width: 1200px) {
      .masonry-column {
        width: 240px;
      }
    }

    @media (max-width: 900px) {
      .masonry-column {
        width: 200px;
      }
      .masonry-container {
        gap: 12px;
      }
    }

    @media (max-width: 768px) {
      .masonry-column {
        width: 180px;
      }
      .masonry-container {
        padding-top: 60px;
        gap: 10px;
      }
      .masonry-item {
        border-radius: 6px;
      }
      .masonry-item img {
        border-radius: 6px;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
      .lightbox-arrow {
        width: 100px;
        height: 250px;
      }
      .lightbox-arrow svg {
        width: 50px;
        height: 50px;
      }
      .lightbox-arrow-left {
        left: 0;
        padding-left: 10px;
      }
      .lightbox-arrow-right {
        right: 0;
        padding-right: 10px;
      }
      .lightbox-close {
        top: 10px;
        right: 10px;
        width: 45px;
        height: 45px;
        font-size: 32px;
      }
    }

    @media (max-width: 480px) {
      .masonry-column {
        width: 140px;
      }
      .masonry-container {
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <script src="../url-handler.js"></script>
  <div class="picasa-bg-blur"></div>
  <div class="picasa-content-wrapper">
    <nav>
      <div class="nav-links">
        <a href="../">Home</a>
        <a href="../arcade">Arcade</a>
        <a href="../picasa" class="active">Picasa</a>
        <a href="../cinema">Cinema</a>
        <a href="../melody">Melody</a>
      </div>
    </nav>
    
    <div class="masonry-container" id="masonryContainer">
      <!-- Columns will be dynamically loaded here -->
    </div>
  </div>

  <!-- Lightbox for image popup with carousel -->
  <div class="lightbox" id="lightbox">
    <button class="lightbox-close" id="lightboxClose">&times;</button>
    
    <!-- Previous arrow -->
    <button class="lightbox-arrow lightbox-arrow-left" id="lightboxPrev">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="40,15 20,35 40,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    
    <div class="lightbox-content">
      <div class="lightbox-image-container">
        <img src="" alt="Enlarged view" id="lightboxImg">
      </div>
      
      <!-- Image metadata -->
      <div class="image-metadata" id="imageMetadata" style="display: none;">
        <!-- Metadata will be populated here -->
      </div>
    </div>
    
    <!-- Next arrow -->
    <button class="lightbox-arrow lightbox-arrow-right" id="lightboxNext">
      <svg width="70" height="70" viewBox="0 0 70 70">
        <polyline points="30,15 50,35 30,55" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <script>
    // Images from photos folder (WebP format for better performance)
    const imagePaths = [
      '../photos/IMG_20240314_122106-ps.webp',
      '../photos/IMG_20240314_125103.webp',
      '../photos/IMG_20240707_191957-ps.webp',
      '../photos/IMG_20240708_081641.webp',
      '../photos/IMG_20240708_091039-ps.webp',
      '../photos/IMG_20240708_094943.webp',
      '../photos/IMG_20240708_132053.webp',
      '../photos/IMG_20240709_120009.webp',
      '../photos/IMG_20240709_120404.webp',
      '../photos/IMG_20240709_121028.webp',
      '../photos/IMG_20240709_121046.webp',
      '../photos/IMG_20240709_121543.webp',
      '../photos/IMG_20240709_122256.webp',
      '../photos/IMG_20240709_122550.webp',
      '../photos/IMG_20240709_122741.webp',
      '../photos/IMG_20250411_184811.webp',
      '../photos/IMG_20250607_081810.webp',
      '../photos/IMG_20250607_113913.webp',
      '../photos/IMG_20250607_115325.webp',
      '../photos/IMG_20250607_115620.webp',
      '../photos/IMG_20250607_124726[1].webp',
      '../photos/IMG_20250607_133643.webp',
      '../photos/IMG_20250607_133654.webp',
      '../photos/IMG_20250607_140358.webp',
      '../photos/IMG_20250607_162802.webp',
      '../photos/IMG_20250607_163003.webp',
      '../photos/IMG_20250607_163255.webp',
      '../photos/IMG_20250608_093739.webp',
      '../photos/IMG_20250608_094940.webp',
      '../photos/IMG_20250608_095348.webp',
      '../photos/IMG_20250809_101547.webp',
      '../photos/IMG_20250831_185402.webp',
      '../photos/IMG_20250831_185711.webp',
      '../photos/IMG_20250831_185730.webp',
      '../photos/IMG_20250831_190528.webp',
      '../photos/IMG_20250903_180808.webp',
      '../photos/IMG_20250903_180928.webp',
      '../photos/Insta-2.webp',
      '../photos/Parrot-2.webp',
      '../photos/Parrot-3.webp',
      '../photos/Sunset.webp',
      '../photos/Test-1.webp',
      '../photos/Test-4.webp',
      '../photos/done1-1.webp',
      '../photos/done1.webp',
      '../photos/post-1.webp',
      '../photos/post-2.webp',
      '../photos/post-3.webp',
      '../photos/post-4.webp',
      '../photos/post.webp',
      '../photos/post3-2.webp',
      '../photos/post3.webp',
      '../photos/post4-1.webp',
      '../photos/shiv.webp'
    ];

    // Get thumbnail path from full image path
    function getThumbnailPath(fullPath) {
      return fullPath.replace('/photos/', '/photos/thumbnails/');
    }

    let shuffledImages = [];
    let currentLightboxIndex = 0;
    const numColumns = 5; // Number of columns

    // Fisher-Yates shuffle algorithm to randomize array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Populate the masonry grid with vertical scrolling columns
    function populateMasonryGrid() {
      const container = document.getElementById('masonryContainer');
      container.innerHTML = ''; // Clear existing content
      
      shuffledImages = shuffleArray(imagePaths);
      
      // Create columns
      const columns = [];
      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'masonry-column';
        column.dataset.columnIndex = i;
        columns.push(column);
        container.appendChild(column);
      }
      
      // Distribute images to columns and duplicate for seamless looping
      const imagesPerColumn = Math.ceil(shuffledImages.length / numColumns);
      
      columns.forEach((column, colIndex) => {
        const startIdx = colIndex * imagesPerColumn;
        const endIdx = Math.min(startIdx + imagesPerColumn, shuffledImages.length);
        const columnImages = shuffledImages.slice(startIdx, endIdx);
        
        // Duplicate images for seamless looping (3 copies for smooth infinite scroll)
        const imagesToRender = [...columnImages, ...columnImages, ...columnImages];
        
        imagesToRender.forEach((imagePath, localIndex) => {
          const originalIndex = startIdx + (localIndex % columnImages.length);
          const item = document.createElement('div');
          item.className = 'masonry-item loading';
          
          // Use thumbnail for gallery view
          const img = document.createElement('img');
          img.src = getThumbnailPath(imagePath);
          img.alt = `Gallery image ${originalIndex + 1}`;
          img.loading = 'lazy';
          img.dataset.index = originalIndex;
          img.dataset.fullPath = imagePath; // Store full path for lightbox
          
          // Remove loading state when thumbnail loads
          img.addEventListener('load', () => {
            img.classList.add('loaded');
            item.classList.remove('loading');
          });
          
          // Add click event for lightbox
          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openLightbox(originalIndex);
          });
          
          item.appendChild(img);
          column.appendChild(item);
        });
        
        // Start vertical scrolling animation for this column
        startColumnAnimation(column, colIndex);
      });
    }

    // Track hover state and pause info for each column
    const columnStates = {};
    
    // Vertical infinite scroll animation with dynamic image recycling and smooth interpolation
    function startColumnAnimation(column, colIndex) {
      // Get all images in column (already tripled)
      const items = Array.from(column.children);
      const baseImageCount = items.length / 3; // Original count before tripling
      
      // Different speeds for each column (5 seconds for testing)
      const baseSpeed = 5;
      const speedVariation = (colIndex * 0.2) - 0.4; // Slight variation per column
      const duration = baseSpeed + speedVariation;
      const pixelsPerSecond = 30; // Reduced scroll speed for smoother motion
      
      // Alternate directions for variety
      const direction = colIndex % 2 === 0 ? 1 : -1;
      
      // Start position with velocity tracking
      let currentPosition = 0;
      let targetPosition = 0;
      let smoothPosition = 0;
      let velocity = 0;
      let smoothVelocity = 0;
      
      let animationId = null;
      let lastFrameTime = performance.now();
      
      // Initialize column state with enhanced smoothing
      columnStates[colIndex] = {
        isPaused: false,
        hoverStartTime: null,
        userScrollVelocity: 0,
        isUserScrolling: false,
        smoothFactor: 0.08, // Lower = more smoothing (0.08 vs 0.15 for ultra-smooth)
        velocitySmoothing: 0.12 // Smoothing factor for velocity changes
      };
      
      const state = columnStates[colIndex];
      
      // Add hover listeners to each image in column for pause on hover
      items.forEach(item => {
        item.addEventListener('mouseenter', () => {
          state.hoverStartTime = performance.now();
        });
        
        item.addEventListener('mouseleave', () => {
          state.hoverStartTime = null;
          state.isPaused = false;
        });
      });
      
      // Add scroll wheel control for any column
      column.addEventListener('wheel', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Only allow scrolling opposite to the column's natural direction
        const scrollDirection = e.deltaY > 0 ? -1 : 1; // deltaY > 0 = scroll down
        
        // Check if user is trying to scroll opposite to the column's auto-scroll direction
        if (scrollDirection !== direction) {
          // User control overrides auto-scroll temporarily
          state.isUserScrolling = true;
          
          // Add to user scroll velocity with reduced speed (0.15 instead of 0.5)
          state.userScrollVelocity += e.deltaY * 0.15;
          
          // Reset user scrolling flag after a delay
          clearTimeout(state.scrollTimeout);
          state.scrollTimeout = setTimeout(() => {
            state.isUserScrolling = false;
            // Gradually decay user velocity back to auto-scroll
            const decayInterval = setInterval(() => {
              if (Math.abs(state.userScrollVelocity) < 1) {
                state.userScrollVelocity = 0;
                clearInterval(decayInterval);
              } else {
                state.userScrollVelocity *= 0.95;
              }
            }, 16);
          }, 150);
        }
      }, { passive: false });
      
      // Easing function for smoother transitions
      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }
      
      function animate(currentTime) {
        const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.05); // Tighter cap at 50ms for more consistent frames
        lastFrameTime = currentTime;
        
        // Check if should pause due to hover (0.5 second delay)
        if (state.hoverStartTime && !state.isPaused) {
          const hoverDuration = currentTime - state.hoverStartTime;
          if (hoverDuration >= 500) { // 0.5 second = 500ms
            state.isPaused = true;
          }
        }
        
        // Calculate target velocity based on state
        let targetVelocity = 0;
        
        if (state.isPaused && !state.isUserScrolling) {
          // Paused - target velocity is zero
          targetVelocity = 0;
        } else if (state.isUserScrolling) {
          // User is scrolling - use user velocity
          targetVelocity = state.userScrollVelocity * 60; // Scale for frame rate
        } else {
          // Auto-scroll mode
          targetVelocity = pixelsPerSecond * direction;
          
          // Blend in any remaining user velocity
          if (Math.abs(state.userScrollVelocity) > 0.1) {
            targetVelocity += state.userScrollVelocity * 30;
          }
        }
        
        // Smooth velocity transitions to prevent jerky changes
        smoothVelocity += (targetVelocity - smoothVelocity) * state.velocitySmoothing;
        
        // Calculate movement from smoothed velocity
        const movement = smoothVelocity * deltaTime;
        
        targetPosition += movement;
        
        // Multi-pass smoothing for ultra-smooth animation
        smoothPosition += (targetPosition - smoothPosition) * state.smoothFactor;
        
        // Use the smoothed position for rendering
        currentPosition = smoothPosition;
        
        // Dynamic image recycling based on direction
        // Only recycle when images are completely off-screen
        const viewportHeight = window.innerHeight;
        
        if (direction === 1) {
          // Scrolling upward - remove from bottom when completely off-screen below
          const lastItem = column.lastElementChild;
          if (lastItem) {
            const itemRect = lastItem.getBoundingClientRect();
            // Only recycle when image is completely below viewport
            if (itemRect.top > viewportHeight + 100) {
              column.removeChild(lastItem);
              column.insertBefore(lastItem, column.firstElementChild);
              const adjustment = lastItem.offsetHeight + 16;
              currentPosition -= adjustment;
              targetPosition -= adjustment;
              smoothPosition -= adjustment;
            }
          }
        } else {
          // Scrolling downward - remove from top when completely off-screen above
          const firstItem = column.firstElementChild;
          if (firstItem) {
            const itemRect = firstItem.getBoundingClientRect();
            // Only recycle when image is completely above viewport
            if (itemRect.bottom < -100) {
              column.removeChild(firstItem);
              column.appendChild(firstItem);
              const adjustment = firstItem.offsetHeight + 16;
              currentPosition += adjustment;
              targetPosition += adjustment;
              smoothPosition += adjustment;
            }
          }
        }
        
        // Use transform for smooth GPU-accelerated animation with integer pixel values
        // Using Math.round() prevents sub-pixel jitter in images
        column.style.transform = `translate3d(0, ${Math.round(currentPosition)}px, 0)`;
        animationId = requestAnimationFrame(animate);
      }
      
      // Start animation
      animationId = requestAnimationFrame(animate);
    }

    // Read EXIF metadata from image
    function readImageMetadata(imgElement, callback) {
      // Check if EXIF library is available
      if (typeof EXIF === 'undefined') {
        callback({}); // Return empty metadata if library not available
        return;
      }
      
      EXIF.getData(imgElement, function() {
        const metadata = {
          make: EXIF.getTag(this, "Make"),
          model: EXIF.getTag(this, "Model"),
          dateTime: EXIF.getTag(this, "DateTime"),
          focalLength: EXIF.getTag(this, "FocalLength"),
          aperture: EXIF.getTag(this, "FNumber"),
          iso: EXIF.getTag(this, "ISOSpeedRatings"),
          exposureTime: EXIF.getTag(this, "ExposureTime"),
          lens: EXIF.getTag(this, "LensModel")
        };
        callback(metadata);
      });
    }

    // Display image metadata
    function displayMetadata(metadata) {
      const metadataDiv = document.getElementById('imageMetadata');
      let hasMetadata = false;
      let html = '';

      if (metadata.dateTime) {
        html += `<div class="metadata-row"><span class="metadata-label">Date & Time:</span> <span class="metadata-value">${metadata.dateTime}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.make || metadata.model) {
        const camera = [metadata.make, metadata.model].filter(Boolean).join(' ');
        html += `<div class="metadata-row"><span class="metadata-label">Camera:</span> <span class="metadata-value">${camera}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.lens) {
        html += `<div class="metadata-row"><span class="metadata-label">Lens:</span> <span class="metadata-value">${metadata.lens}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.focalLength) {
        const focal = metadata.focalLength.numerator ? 
          `${metadata.focalLength.numerator / metadata.focalLength.denominator}mm` : 
          `${metadata.focalLength}mm`;
        html += `<div class="metadata-row"><span class="metadata-label">Focal Length:</span> <span class="metadata-value">${focal}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.aperture) {
        const aperture = metadata.aperture.numerator ? 
          `f/${(metadata.aperture.numerator / metadata.aperture.denominator).toFixed(1)}` : 
          `f/${metadata.aperture}`;
        html += `<div class="metadata-row"><span class="metadata-label">Aperture:</span> <span class="metadata-value">${aperture}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.exposureTime) {
        const exposure = metadata.exposureTime.numerator ? 
          `${metadata.exposureTime.numerator}/${metadata.exposureTime.denominator}s` : 
          `${metadata.exposureTime}s`;
        html += `<div class="metadata-row"><span class="metadata-label">Shutter Speed:</span> <span class="metadata-value">${exposure}</span></div>`;
        hasMetadata = true;
      }

      if (metadata.iso) {
        html += `<div class="metadata-row"><span class="metadata-label">ISO:</span> <span class="metadata-value">${metadata.iso}</span></div>`;
        hasMetadata = true;
      }

      if (hasMetadata) {
        metadataDiv.innerHTML = html;
        metadataDiv.style.display = 'block';
      } else {
        metadataDiv.style.display = 'none';
      }
    }

    // Lightbox functionality
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');

    function openLightbox(index) {
      currentLightboxIndex = index;
      showLightboxImage();
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function showLightboxImage() {
      const imageSrc = shuffledImages[currentLightboxIndex];
      lightboxImg.src = imageSrc;
      
      // Read and display metadata
      lightboxImg.onload = function() {
        readImageMetadata(lightboxImg, displayMetadata);
      };
    }

    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
      document.getElementById('imageMetadata').style.display = 'none';
    }

    function showPrevImage() {
      currentLightboxIndex = (currentLightboxIndex - 1 + shuffledImages.length) % shuffledImages.length;
      showLightboxImage();
    }

    function showNextImage() {
      currentLightboxIndex = (currentLightboxIndex + 1) % shuffledImages.length;
      showLightboxImage();
    }

    // Event listeners
    lightboxClose.addEventListener('click', (e) => {
      e.stopPropagation();
      closeLightbox();
    });
    
    lightboxPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      showPrevImage();
    });
    
    lightboxNext.addEventListener('click', (e) => {
      e.stopPropagation();
      showNextImage();
    });
    
    // Close lightbox when clicking outside the image
    lightbox.addEventListener('click', function(e) {
      if (e.target === lightbox) {
        closeLightbox();
      }
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      if (e.key === 'Escape') {
        closeLightbox();
      } else if (e.key === 'ArrowLeft') {
        showPrevImage();
      } else if (e.key === 'ArrowRight') {
        showNextImage();
      }
    });

    // Touch swipe support for mobile
    let touchStartX = 0;
    let touchEndX = 0;
    
    lightbox.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });
    
    lightbox.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    }, { passive: true });
    
    function handleSwipe() {
      const swipeThreshold = 50;
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Swipe left - next image
          showNextImage();
        } else {
          // Swipe right - previous image
          showPrevImage();
        }
      }
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
      populateMasonryGrid();
    });
  </script>
</body>
</html>
